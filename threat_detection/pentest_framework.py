import argparse
import time
import random
import socket
import sys
import subprocess
from datetime import datetime
import threading
import ipaddress

class PenetrationTester:
    def __init__(self, target, ports=None, verbose=False):
        self.target = target
        self.ports = ports or [21, 22, 23, 25, 53, 80, 110, 135, 139, 143, 443, 445, 993, 995, 1723, 3306, 3389, 5900, 8080]
        self.verbose = verbose
        self.results = {}
        self.vulnerabilities_found = []
        
    def log(self, message, level="INFO"):
        """Log messages with timestamps"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        print(f"[{timestamp}] [{level}] {message}")
    
    def port_scan(self, scan_type="tcp"):
        """Perform port scanning"""
        self.log(f"Starting {scan_type.upper()} port scan on {self.target}")
        open_ports = []
        
        if scan_type == "tcp":
            for port in self.ports:
                try:
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.settimeout(1)
                    result = sock.connect_ex((self.target, port))
                    
                    if result == 0:
                        self.log(f"Port {port} is OPEN", "SUCCESS")
                        open_ports.append(port)
                        # Try to grab banner
                        try:
                            sock.send(b'HEAD / HTTP/1.0\r\n\r\n')
                            banner = sock.recv(1024).decode('utf-8', errors='ignore')[:100]
                            if banner:
                                self.log(f"  Banner: {banner.strip()}", "INFO")
                        except:
                            pass
                    elif self.verbose:
                        self.log(f"Port {port} is closed", "DEBUG")
                    
                    sock.close()
                    
                except Exception as e:
                    if self.verbose:
                        self.log(f"Error scanning port {port}: {e}", "ERROR")
        
        self.results['open_ports'] = open_ports
        return open_ports
    
    def service_detection(self, ports):
        """Detect services running on open ports"""
        self.log("Starting service detection...")
        services = {}
        
        service_map = {
            21: 'FTP',
            22: 'SSH',
            23: 'Telnet',
            25: 'SMTP',
            53: 'DNS',
            80: 'HTTP',
            110: 'POP3',
            135: 'MSRPC',
            139: 'NetBIOS',
            143: 'IMAP',
            443: 'HTTPS',
            445: 'SMB',
            993: 'IMAPS',
            995: 'POP3S',
            1723: 'PPTP',
            3306: 'MySQL',
            3389: 'RDP',
            5900: 'VNC',
            8080: 'HTTP-Proxy'
        }
        
        for port in ports:
            service = service_map.get(port, 'Unknown')
            services[port] = service
            self.log(f"Port {port}: {service}", "INFO")
            
            # Try to get more info
            if port in [80, 443, 8080]:
                self.web_server_fingerprint(port)
        
        self.results['services'] = services
        return services
    
    def web_server_fingerprint(self, port):
        """Fingerprint web servers"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(2)
            sock.connect((self.target, port))
            
            sock.send(b'HEAD / HTTP/1.0\r\n\r\n')
            response = sock.recv(1024).decode('utf-8', errors='ignore')
            
            if 'Server:' in response:
                server_header = [line for line in response.split('\n') if 'Server:' in line][0]
                self.log(f"  Web Server: {server_header.strip()}", "DETAIL")
            
            sock.close()
        except:
            pass
    
    def vulnerability_scan(self):
        """Simulate vulnerability scanning"""
        self.log("Starting vulnerability assessment...")
        
        # Simulated vulnerabilities (for demonstration)
        common_vulns = [
            {
                'name': 'Weak SSH Configuration',
                'risk': 'HIGH',
                'port': 22,
                'description': 'SSH server allows password authentication',
                'cve': 'CVE-2018-15473'
            },
            {
                'name': 'SMBv1 Enabled',
                'risk': 'CRITICAL',
                'port': 445,
                'description': 'SMBv1 protocol enabled (vulnerable to EternalBlue)',
                'cve': 'CVE-2017-0144'
            },
            {
                'name': 'Outdated Apache Version',
                'risk': 'MEDIUM',
                'port': 80,
                'description': 'Apache 2.4.29 detected (multiple known vulnerabilities)',
                'cve': 'CVE-2019-0211'
            },
            {
                'name': 'MySQL Empty Root Password',
                'risk': 'CRITICAL',
                'port': 3306,
                'description': 'MySQL root account has empty password',
                'cve': 'CVE-2012-2122'
            },
            {
                'name': 'WordPress Version Disclosure',
                'risk': 'LOW',
                'port': 80,
                'description': 'WordPress version 4.7.5 detected in meta tags',
                'cve': 'CVE-2017-8295'
            }
        ]
        
        for vuln in common_vulns:
            # Simulate random discovery (for demo)
            if random.random() > 0.5:  # 50% chance of "finding" each vulnerability
                self.vulnerabilities_found.append(vuln)
                risk_color = {
                    'CRITICAL': '[CRITICAL]',
                    'HIGH': '[HIGH]',
                    'MEDIUM': '[MEDIUM]',
                    'LOW': '[LOW]'
                }.get(vuln['risk'], '')
                
                self.log(f"{risk_color} {vuln['name']} (Port: {vuln['port']})", "VULN")
                self.log(f"    Description: {vuln['description']}", "DETAIL")
                self.log(f"    CVE: {vuln['cve']}", "DETAIL")
        
        self.results['vulnerabilities'] = self.vulnerabilities_found
        return self.vulnerabilities_found
    
    def brute_force_simulation(self, service, port):
        """Simulate brute force attack (educational)"""
        self.log(f"Simulating brute force attack on {service} (port {port})", "WARNING")
        
        # Simulated credentials (for demo only)
        common_credentials = [
            ('admin', 'admin'),
            ('admin', 'password'),
            ('root', 'root'),
            ('user', 'user'),
            ('administrator', ''),
            ('guest', 'guest')
        ]
        
        self.log("Testing common credentials...", "INFO")
        
        for username, password in common_credentials:
            # Simulate login attempt
            time.sleep(0.1)
            
            # Random success (for demo)
            if random.random() < 0.1:  # 10% chance of "success"
                self.log(f"✓ SUCCESS: {username}:{password}", "CRITICAL")
                return {'service': service, 'username': username, 'password': password}
            else:
                if self.verbose:
                    self.log(f"  Failed: {username}:{password}", "DEBUG")
        
        self.log("Brute force simulation completed - no credentials found", "INFO")
        return None
    
    def sql_injection_test(self, url_path="/"):
        """Test for SQL injection vulnerabilities"""
        self.log(f"Testing for SQL injection on {self.target}{url_path}", "INFO")
        
        # Common SQL injection payloads
        payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "admin' --",
            "1' OR '1'='1",
            "' UNION SELECT null, version() --"
        ]
        
        vulnerabilities = []
        
        for payload in payloads:
            # Simulate testing
            time.sleep(0.2)
            
            # Random "vulnerability discovery" (for demo)
            if random.random() < 0.3:  # 30% chance
                vuln = {
                    'type': 'SQL Injection',
                    'payload': payload,
                    'risk': 'HIGH',
                    'description': f'Parameter vulnerable to SQLi with payload: {payload}'
                }
                vulnerabilities.append(vuln)
                self.log(f"✓ Potential SQLi vulnerability found with payload: {payload}", "VULN")
        
        if vulnerabilities:
            self.vulnerabilities_found.extend(vulnerabilities)
        
        return vulnerabilities
    
    def xss_test(self, url_path="/"):
        """Test for Cross-Site Scripting vulnerabilities"""
        self.log(f"Testing for XSS on {self.target}{url_path}", "INFO")
        
        payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "\"><script>alert('XSS')</script>",
            "javascript:alert('XSS')"
        ]
        
        vulnerabilities = []
        
        for payload in payloads:
            time.sleep(0.2)
            
            if random.random() < 0.2:  # 20% chance
                vuln = {
                    'type': 'Cross-Site Scripting (XSS)',
                    'payload': payload,
                    'risk': 'MEDIUM',
                    'description': f'Reflected XSS possible with payload: {payload}'
                }
                vulnerabilities.append(vuln)
                self.log(f"✓ Potential XSS vulnerability found with payload: {payload}", "VULN")
        
        if vulnerabilities:
            self.vulnerabilities_found.extend(vulnerabilities)
        
        return vulnerabilities
    
    def generate_report(self):
        """Generate penetration testing report"""
        self.log("Generating penetration testing report...", "INFO")
        
        print("\n" + "="*80)
        print("🔍 PENETRATION TESTING REPORT")
        print("="*80)
        print(f"Target: {self.target}")
        print(f"Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"Duration: {getattr(self, 'scan_duration', 'N/A')}")
        print("-"*80)
        
        # Open Ports
        if 'open_ports' in self.results:
            print("\n📊 OPEN PORTS:")
            for port in self.results['open_ports']:
                service = self.results['services'].get(port, 'Unknown')
                print(f"  Port {port}: {service}")
        
        # Vulnerabilities
        if self.vulnerabilities_found:
            print("\n⚠️  VULNERABILITIES FOUND:")
            
            # Group by risk level
            by_risk = {'CRITICAL': [], 'HIGH': [], 'MEDIUM': [], 'LOW': []}
            for vuln in self.vulnerabilities_found:
                risk = vuln.get('risk', 'MEDIUM')
                by_risk[risk].append(vuln)
            
            # ANSI color codes for Windows
            reset_code = ""
            color_codes = {
                'CRITICAL': '',
                'HIGH': '',
                'MEDIUM': '',
                'LOW': ''
            }
            
            for risk_level in ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']:
                vulns = by_risk[risk_level]
                if vulns:
                    color_code = color_codes.get(risk_level, '')
                    print(f"\n{color_code}{risk_level} RISK ({len(vulns)}){reset_code}")
                    
                    for vuln in vulns:
                        name = vuln.get('name', vuln.get('type', 'Unknown'))
                        port = vuln.get('port', 'N/A')
                        cve = vuln.get('cve', '')
                        print(f"    • {name} (Port: {port}) {cve}")
        
        # Recommendations
        print("\n🎯 RECOMMENDATIONS:")
        print("  1. Close unnecessary ports")
        print("  2. Update all software to latest versions")
        print("  3. Implement strong password policies")
        print("  4. Configure firewalls and IDS/IPS")
        print("  5. Regular security audits and patching")
        
        print("\n" + "="*80)
        print("📈 RISK SUMMARY:")
        critical_count = len([v for v in self.vulnerabilities_found if v.get('risk') == 'CRITICAL'])
        high_count = len([v for v in self.vulnerabilities_found if v.get('risk') == 'HIGH'])
        
        if critical_count > 0:
            print(f"🔴 CRITICAL RISK: {critical_count} critical vulnerabilities found")
        elif high_count > 0:
            print(f"🟡 HIGH RISK: {high_count} high-risk vulnerabilities found")
        elif self.vulnerabilities_found:
            print("🟢 MODERATE RISK: Vulnerabilities found but none critical")
        else:
            print("✅ LOW RISK: No significant vulnerabilities detected")
        
        print("="*80)
        
        return self.results

def main():
    parser = argparse.ArgumentParser(description='Penetration Testing Framework')
    parser.add_argument('target', help='Target IP address or hostname')
    parser.add_argument('-p', '--ports', help='Ports to scan (comma-separated or range)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Verbose output')
    parser.add_argument('-m', '--mode', choices=['quick', 'full', 'web', 'network'], 
                       default='quick', help='Scan mode')
    parser.add_argument('-o', '--output', help='Output file for report')
    
    args = parser.parse_args()
    
    # Parse ports
    ports = None
    if args.ports:
        if '-' in args.ports:
            start, end = map(int, args.ports.split('-'))
            ports = list(range(start, end + 1))
        elif ',' in args.ports:
            ports = list(map(int, args.ports.split(',')))
        else:
            ports = [int(args.ports)]
    
    print("="*80)
    print("🔐 PENETRATION TESTING FRAMEWORK")
    print("="*80)
    print(f"Target: {args.target}")
    print(f"Mode: {args.mode.upper()}")
    print(f"Start Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("="*80)
    
    # Safety warning
    print("\n⚠️  WARNING: This tool is for authorized testing only!")
    print("   Unauthorized testing is illegal and unethical.")
    print("   Use only on systems you own or have permission to test.")
    print("-"*80)
    
    tester = PenetrationTester(args.target, ports, args.verbose)
    start_time = time.time()
    
    try:
        # Port scanning
        open_ports = tester.port_scan()
        
        if open_ports:
            # Service detection
            services = tester.service_detection(open_ports)
            
            # Vulnerability scanning
            vulns = tester.vulnerability_scan()
            
            # Additional tests based on mode
            if args.mode in ['full', 'web']:
                tester.sql_injection_test()
                tester.xss_test()
            
            if args.mode in ['full', 'network']:
                # Simulate brute force on common services
                for port, service in services.items():
                    if service in ['SSH', 'FTP', 'Telnet', 'RDP']:
                        tester.brute_force_simulation(service, port)
        
        tester.scan_duration = f"{time.time() - start_time:.1f} seconds"
        
        # Generate report
        report = tester.generate_report()
        
        # Save to file if requested
        if args.output:
            import json
            with open(args.output, 'w') as f:
                json.dump(report, f, indent=2)
            print(f"\n📄 Report saved to: {args.output}")
        
    except KeyboardInterrupt:
        print("\n\n⏹️  Scan interrupted by user")
    except Exception as e:
        print(f"\n❌ Error during scan: {e}")

if __name__ == "__main__":
    main()
