import subprocess
import time
import json
from datetime import datetime
import argparse

def run_pentest_suite(target, output_file=None):
    """Run complete penetration testing suite"""
    
    print("="*100)
    print("🎯 COMPREHENSIVE PENETRATION TESTING SUITE")
    print("="*100)
    print(f"Target: {target}")
    print(f"Start Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"Output File: {output_file or 'Screen output only'}")
    print("="*100)
    
    results = {
        'target': target,
        'start_time': datetime.now().isoformat(),
        'tests': []
    }
    
    tests = [
        {
            'name': 'Network Reconnaissance',
            'command': f'python src/threat_detection/network_scanner.py {target} -m discover',
            'duration': 30
        },
        {
            'name': 'Port & Service Scanning',
            'command': f'python src/threat_detection/pentest_framework.py {target} -m quick',
            'duration': 60
        },
        {
            'name': 'Vulnerability Assessment',
            'command': f'python src/threat_detection/pentest_framework.py {target} -m full -p "1-1000"',
            'duration': 120
        },
        {
            'name': 'Web Application Scanning',
            'command': f'python src/threat_detection/web_scanner.py http://{target} -d 3',
            'duration': 90
        },
        {
            'name': 'Password Security Audit',
            'command': f'python src/threat_detection/security_tools.py strength "password123"',
            'duration': 10
        }
    ]
    
    for test in tests:
        print(f"\n{'='*80}")
        print(f"🚀 TEST: {test['name']}")
        print(f"{'='*80}")
        print(f"Command: {test['command']}")
        print(f"Timeout: {test['duration']} seconds")
        print(f"{'-'*80}")
        
        start_time = time.time()
        
        try:
            # Run the test with timeout
            result = subprocess.run(
                test['command'],
                shell=True,
                capture_output=True,
                text=True,
                timeout=test['duration']
            )
            
            elapsed = time.time() - start_time
            
            # Store results
            test_result = {
                'name': test['name'],
                'command': test['command'],
                'duration': elapsed,
                'success': result.returncode == 0,
                'stdout': result.stdout[-5000:],  # Last 5000 chars
                'stderr': result.stderr[-1000:]   # Last 1000 chars
            }
            
            results['tests'].append(test_result)
            
            # Display output
            print(f"\nOutput:")
            print(result.stdout[-2000:])  # Last 2000 chars
            
            if result.stderr:
                print(f"\nErrors:")
                print(result.stderr[-1000:])
            
            print(f"\n✅ Test completed in {elapsed:.1f} seconds")
            
        except subprocess.TimeoutExpired:
            print(f"\n⏰ Test timed out after {test['duration']} seconds")
        except Exception as e:
            print(f"\n❌ Test failed: {e}")
        
        time.sleep(2)  # Pause between tests
    
    # Generate summary
    results['end_time'] = datetime.now().isoformat()
    total_time = (datetime.fromisoformat(results['end_time']) - 
                  datetime.fromisoformat(results['start_time'])).total_seconds()
    
    print(f"\n{'='*100}")
    print("📊 PENETRATION TESTING SUITE - FINAL REPORT")
    print(f"{'='*100}")
    print(f"Target: {target}")
    print(f"Start Time: {results['start_time']}")
    print(f"End Time: {results['end_time']}")
    print(f"Total Duration: {total_time:.1f} seconds")
    print(f"Tests Run: {len(results['tests'])}")
    
    successful = sum(1 for t in results['tests'] if t.get('success'))
    print(f"Successful Tests: {successful}/{len(results['tests'])}")
    
    print(f"\n{'='*100}")
    print("🎯 SECURITY RECOMMENDATIONS")
    print(f"{'='*100}")
    print("1. Regular vulnerability scanning and patching")
    print("2. Implement strong access controls")
    print("3. Enable logging and monitoring")
    print("4. Regular security awareness training")
    print("5. Incident response planning")
    print("6. Data encryption at rest and in transit")
    print("7. Network segmentation")
    print("8. Regular backups and recovery testing")
    print(f"{'='*100}")
    
    # Save results if output file specified
    if output_file:
        with open(output_file, 'w') as f:
            json.dump(results, f, indent=2)
        print(f"\n📄 Full results saved to: {output_file}")
    
    print(f"\n⚠️  IMPORTANT: This is a simulation for educational purposes.")
    print("   Always obtain proper authorization before testing.")
    print("   Follow responsible disclosure for any findings.")
    
    return results

def main():
    parser = argparse.ArgumentParser(description='Complete Penetration Testing Suite')
    parser.add_argument('target', help='Target IP address or hostname')
    parser.add_argument('-o', '--output', help='Output JSON file for results')
    
    args = parser.parse_args()
    
    # Safety warning
    print("\n" + "="*100)
    print("⚠️  WARNING: PENETRATION TESTING TOOLS")
    print("="*100)
    print("These tools simulate real attacks and should ONLY be used:")
    print("  1. On systems you own")
    print("  2. With explicit written permission")
    print("  3. In isolated test environments")
    print("  4. For educational purposes")
    print("\nUnauthorized testing is ILLEGAL and UNETHICAL.")
    print("="*100)
    
    response = input("\nDo you have authorization to test this target? (yes/no): ")
    if response.lower() != 'yes':
        print("Test cancelled. Always get proper authorization.")
        return
    
    run_pentest_suite(args.target, args.output)

if __name__ == "__main__":
    main()
